// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.18.0
// source: user_falt.sql

package db

import (
	"context"
	"database/sql"
	"time"
)

const createUserFlat = `-- name: CreateUserFlat :one
INSERT INTO user_flats (
  user_id, flat_id, is_admin, balance
) VALUES (
  $1, $2, $3, $4
)
RETURNING id, user_id, flat_id, is_admin, balance, deleted_at, created_at, updated_at
`

type CreateUserFlatParams struct {
	UserID  int32
	FlatID  int32
	IsAdmin bool
	Balance float64
}

// Create
func (q *Queries) CreateUserFlat(ctx context.Context, arg CreateUserFlatParams) (UserFlat, error) {
	row := q.db.QueryRowContext(ctx, createUserFlat,
		arg.UserID,
		arg.FlatID,
		arg.IsAdmin,
		arg.Balance,
	)
	var i UserFlat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FlatID,
		&i.IsAdmin,
		&i.Balance,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getUserFlat = `-- name: GetUserFlat :one
SELECT id, user_id, flat_id, is_admin, balance, deleted_at, created_at, updated_at FROM user_flats
WHERE id = $1 AND deleted_at IS NULL
`

// Read
func (q *Queries) GetUserFlat(ctx context.Context, id int32) (UserFlat, error) {
	row := q.db.QueryRowContext(ctx, getUserFlat, id)
	var i UserFlat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FlatID,
		&i.IsAdmin,
		&i.Balance,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const hardDeleteUserFlat = `-- name: HardDeleteUserFlat :exec
DELETE FROM user_flats
WHERE id = $1
`

// Hard Delete
func (q *Queries) HardDeleteUserFlat(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, hardDeleteUserFlat, id)
	return err
}

const listUserFlats = `-- name: ListUserFlats :many
SELECT uf.id, uf.user_id, uf.flat_id, uf.is_admin, uf.balance, uf.deleted_at, uf.created_at, uf.updated_at, u.username, f.name as flat_name FROM user_flats uf
JOIN users u ON uf.user_id = u.username
JOIN flats f ON uf.flat_id = f.id
WHERE uf.deleted_at IS NULL
ORDER BY uf.created_at DESC
LIMIT $1 OFFSET $2
`

type ListUserFlatsParams struct {
	Limit  int32
	Offset int32
}

type ListUserFlatsRow struct {
	ID        int32
	UserID    int32
	FlatID    int32
	IsAdmin   bool
	Balance   float64
	DeletedAt sql.NullTime
	CreatedAt time.Time
	UpdatedAt time.Time
	Username  string
	FlatName  string
}

// List with pagination
func (q *Queries) ListUserFlats(ctx context.Context, arg ListUserFlatsParams) ([]ListUserFlatsRow, error) {
	rows, err := q.db.QueryContext(ctx, listUserFlats, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListUserFlatsRow
	for rows.Next() {
		var i ListUserFlatsRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.FlatID,
			&i.IsAdmin,
			&i.Balance,
			&i.DeletedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Username,
			&i.FlatName,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const softDeleteUserFlat = `-- name: SoftDeleteUserFlat :exec
UPDATE user_flats
SET 
  deleted_at = CURRENT_TIMESTAMP
WHERE id = $1
`

// Delete (Soft Delete)
func (q *Queries) SoftDeleteUserFlat(ctx context.Context, id int32) error {
	_, err := q.db.ExecContext(ctx, softDeleteUserFlat, id)
	return err
}

const updateUserFlat = `-- name: UpdateUserFlat :one
UPDATE user_flats
SET 
  is_admin = $1, 
  balance = $2
WHERE id = $3 AND deleted_at IS NULL
RETURNING id, user_id, flat_id, is_admin, balance, deleted_at, created_at, updated_at
`

type UpdateUserFlatParams struct {
	IsAdmin bool
	Balance float64
	ID      int32
}

// Update
func (q *Queries) UpdateUserFlat(ctx context.Context, arg UpdateUserFlatParams) (UserFlat, error) {
	row := q.db.QueryRowContext(ctx, updateUserFlat, arg.IsAdmin, arg.Balance, arg.ID)
	var i UserFlat
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.FlatID,
		&i.IsAdmin,
		&i.Balance,
		&i.DeletedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
